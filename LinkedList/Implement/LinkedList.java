package LinkedList.Implement;

public class LinkedList<E> {
	class Node<E>{
		E data;
		Node<E> next;
		
		public Node(E data) {
			this.data = data;
			this.next = null;
		}	
	}
	
	private Node<E> head;
	private Node<E> tail;
	private int currentSize;
	
	public LinkedList(){
		head = null;
		tail = null;
		currentSize = 0;
	}
	
	public void addFirst(E data) {
		Node<E> newNode = new Node<E>(data);
		
		// 1. 경계조건, 자료구조가 비어있는 경우
		if(head==null)
		{
			tail = newNode;
		}
		
		newNode.next = head;
		head = newNode;		
		currentSize++;
	}
	
	public void addLast(E data) {
		
		Node<E> newNode = new Node<E>(data);
		// 1. 경계조건, 자료구조가 비어있는 경우
		if(head==null)
		{
			head = tail = newNode;
			currentSize++;
			return;
		}
		
		tail.next = newNode;		
		tail = newNode;
		
		currentSize++;
	}
	
	public E removeFirst() {
		// 경계조건 1. Empty, 자료구조가 비어있는 경우
		if(head==null)
		{
			return null;
		}
		
		E delData = head.data;
		
		// 경계조건 2. Single Element, 삭제할 노드가 단 하나남은 노드인 경우 
		// head, tail은 null을 가리키도록 함
		if(head==tail)
		{
			head = tail = null;
		}
		else
		{
			head = head.next;
		}
		
		currentSize--;
		
		return delData;
	}
	
	public E removeLast() {
		// 경계조건 1. Empty, 자료구조가 비어있는 경우
		if(head==null)
		{
			return null;
		}
		
		// 경계조건 2. Single Element, 자료구조에서 요소가 하나 있는 경우
		if(head==tail)
		{
			return removeFirst();
		}
		
		Node<E> current = head;
		Node<E> previous = null;
		
		while(current!=tail)
		{
			previous = current;
			current = current.next;		 
		}
		
		previous.next = null;
		tail = previous;
		
		currentSize--;
		
		return current.data;
		
	}
	
	public E remove(E obj) {
		Node<E> current=head, previous=null;
		
		// 경계 조건 Empty 포함
		while(current!=null)
		{
			// 찾고자 하는 요소인 경우
			if(((Comparable<E>)obj).compareTo(current.data)==0)
			{
				// 경계조건 Single Element, Beginning
				if(current==head)
				{
					return removeFirst();
				}
				// 경계조건 End
				if(current==tail)
				{
					return removeLast();
				}
				// 경계조건 Middle 포함
				previous.next = current.next;
				currentSize--;
				return current.data;
			}
			// 찾고자 하는 요소가 아닌 경우
			previous = current;
			current = current.next;
		}
	
		return null;
	}
	
	public boolean contains(E obj)
	{
		Node<E> current=head;
		
		// 경계 조건 Empty 포함
		while(current!=null)
		{
			// 찾고자 하는 요소인 경우
			if(((Comparable<E>)obj).compareTo(current.data)==0)
			{
				return true;
			}
			// 찾고자 하는 요소가 아닌 경우
			current = current.next;
		}
		
		// 요소가 포함되지 않은 경우
		return false;
	}
	

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		Node<E> cur = head;
		
		while(cur!=null)
		{
			sb.append(cur.data + " ");
			cur=cur.next;
		}
		sb.append("\n");
		
		return sb.toString().trim();
	}
	
	
}
