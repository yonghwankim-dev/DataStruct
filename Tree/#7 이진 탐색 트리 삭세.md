### 1\. 이진 탐색 트리에서 노드가 삭제되는 3가지 상황

![](https://github.com/yonghwankim-dev/DataStruct/blob/main/Tree/img/%237%20%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89%20%ED%8A%B8%EB%A6%AC%20%EC%82%AD%EC%A0%9C/01_deleteCase1BST.png)
![](https://github.com/yonghwankim-dev/DataStruct/blob/main/Tree/img/%237%20%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89%20%ED%8A%B8%EB%A6%AC%20%EC%82%AD%EC%A0%9C/02_deleteCase2BST.png)
![](https://github.com/yonghwankim-dev/DataStruct/blob/main/Tree/img/%237%20%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89%20%ED%8A%B8%EB%A6%AC%20%EC%82%AD%EC%A0%9C/03_deleteCase3BST.png)

### 2\. 이진 탐색 트리에서 Inorder Successor란 무엇인가?

이진 탐색 트리에서 Inorder Successor은 입력된 키 값보다 큰 값들중 제일 작은 수를 의미한다. Inorder Successor는 정렬된 순서에서 다음 노드를 탐색하기 위해서 중요하게 사용된다.

![](https://github.com/yonghwankim-dev/DataStruct/blob/main/Tree/img/%237%20%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89%20%ED%8A%B8%EB%A6%AC%20%EC%82%AD%EC%A0%9C/04_inorderSuccessor.png)

위의 이진 탐색 트리에서 8의 inorder successor는 10이고 10의 경우에는 12, 14의 경우에는 20이 inorder successor 입니다.

**Inorder Successor 구현 방법 : 부모 포인터를 사용하는 방법**

이 알고리즘에서는 모든 노드는 부모 포인터를 가지고 있다고 가정합니다. 그리고 이 구현 방법에는 입력 노드의 오른쪽 서브트리가 비어있는 경우나 비어있지 않는 경우의 두가지 케이스로 나누어집니다.

입력(Input) : inorder successor 노드의 기준이 되는 노드(node)

출력(Output) : node의 inorder successor 노드

1\. 만약 노드의 오른쪽 서브트리가 null이 아닌 경우, **노드의 오른쪽 서브트리의 제일 작은 수를 반환한다.** 오른쪽 서브 트리도 또 하나의 이진 탐색 트리이므로 제일 왼쪽 자식 노드가 제일 작은 수이다. 루트 노드(20)를 기준으로 제일 작은 수는 노드 4이다.

2\. 만약 노드의 오른쪽 서브트리가 null인 경우, 노드의 조상 중에 하나가 inorder successor 노드이다. 이 경우에 **노드를 기준으로 부모 노드를 타고 올라가다가 부모 노드를 기준으로 노드가 왼쪽 자식인 경우 해당 부모 노드가 inorder successor 노드이다.** 예를 들어 위의 그림에서 14의 inorder successor 노드를 찾기 위해서는 자신의 부모 노드인 12->8 노드로 올라간다. 그중에서 기준 노드가 8노드로 이동하고 부모 노드인 20 노드를 참조 시 20 노드를 기준으로 기준 노드인 8 노드는 왼쪽 자식이기 때문에 20 노드가 14의 inorder successor 노드이다.

inorder successor 구현 방법의 구현

```
// 이진 탐색 트리의 탐색, 삽입, 삭제를 예제
public class BinarySearchTree {
	public static class Node 
	{
		int key;
		Node left, right, parent;

		public Node(int item) 
		{
			key = item;
			left = right = parent = null;
		}
	}

	Node root;

	BinarySearchTree() {
		root = null;
	}

	void insert(int key) {
		root = insertRec(root, key);
	}

	private Node insertRec(Node root, int key) {

		// 루트 노드가 비어있는 경우 생성
		if (root == null) {
			root = new Node(key);
			return root;
		}

		if (key < root.key)	// 왼쪽 서브트리로 이동
		{
			
			root.left = insertRec(root.left, key);
			root.left.parent = root;
		}
		else if (key > root.key)	// 오른쪽 서브트리로 이동
		{
			root.right = insertRec(root.right, key);
			root.right.parent = root;
		}
		return root;
	}

	void inorder() {
		inorderRec(root);
		System.out.println();
	}

	private void inorderRec(Node root) {
		if (root != null) {
			inorderRec(root.left);
			System.out.print(root.key + " ");
			inorderRec(root.right);
		}
	}
	
	public Node inorderSuccessor(Node n)
	{
		// case 1 : 오른쪽 서브트리가 존재하는 경우
		if(n.right!=null)
		{
			return minValue(n.right);
		}
		
		// case 2 : 오른쪽 서브트리가 null인 경우
		Node p = n.parent;
		// root 노드의 경우 p=null이므로 null 반환,
		// n과 p의 관계가 오른쪽 자식과 부모인 관계동안 부모를 타고 올라간다.
		while(p!=null && n==p.right) {
			n = p;
			p = p.parent;
		}
		return p;
	}
	
	// n 트리를 기준으로 제일 작은 수의 노드를 반환
	private Node minValue(Node n)
	{
		Node current = n;
		
		// 노드 n을 기준으로 제일 왼쪽 자식 노드를 탐색한다.
		while(current.left!=null)
		{
			current = current.left;
		}
		return current;
		
	}
}
```

```
import org.junit.jupiter.api.Test;
import Tree.BST.Implement.BinarySearchTree.Node;

class BinarySearchTreeTest {
	
	@Test
	void inorderSuccessorTest() {
		BinarySearchTree tree = new BinarySearchTree();

		tree.insert(20);
		tree.insert(8);
		tree.insert(22);
		tree.insert(4);
		tree.insert(12);
		tree.insert(10);
		tree.insert(14);

		Node temp = tree.root.left.right.right;	// 14
		System.out.println(tree.inorderSuccessor(temp).key);	// Expected Output : 20
	}

}
```

```
Output

20
```

복잡도 분석

1\. 시간 복잡도(Time Complexity) : O(h), h는 트리의 높이(height)이다. 2번째 케이스때문에 최악의 경우 루트까지 순회를 해야 합니다.

2\. 보조 공간 복잡도(Auxilary Space) : O(1), 정렬된 값에 대한 데이터 구조를 사용하지 않기 때문에 O(1)이 나옵니다.

### 3\. 이진 탐색 트리 삭제(Delete) 구현

```
// 이진 탐색 트리의 탐색, 삽입, 삭제를 예제
public class BinarySearchTree {
	public static class Node 
	{
		int key;
		Node left, right, parent;

		public Node(int item) 
		{
			key = item;
			left = right = parent = null;
		}
	}

	Node root;

	BinarySearchTree() {
		root = null;
	}
	
	
	void delete(int key){
		root = deleteRec(root, key);
	}
	
	// 이진 탐색 트리에서 존재하는지 키를 제거하기 위한 재귀적인 메서드
	private Node deleteRec(Node root, int key) {
		// Base case : 만약 트리(root)가 비어있는 경우ㅜ
		if(root==null)
		{
			return root;
		}
		
		// Otherwise, 트리의 자식으로 이동
		if(key < root.key)
		{
			root.left = deleteRec(root.left, key);
		}
		else if(key > root.key)
		{
			root.right = deleteRec(root.right, key);
		}
		else	// 만약 삭제할 노드를 찾은 경우
		{
			// 삭제할 노드가 하나의 자식 노드이거나 둘다 자식이 없는경우 검사
			if(root.left==null)
			{
				return root.right;
			}
			else if(root.right==null)
			{
				return root.left;
			}
			
			// 삭제할 노드가 왼쪽 자식, 오른쪽 자식 모두 있는 경우
			// inorder successor를 탐색한다. (root의 값보다 큰수 중 제일 작은 값)
			root.key = minValue(root.right).key;
			
			// inorder successor 노드를 제거한다.
			root.right = deleteRec(root.right, root.key);
			
		}
		return root;
		
	}

	void insert(int key) {
		root = insertRec(root, key);
	}

	private Node insertRec(Node root, int key) {

		// 루트 노드가 비어있는 경우 생성
		if (root == null) {
			root = new Node(key);
			return root;
		}

		if (key < root.key)	// 왼쪽 서브트리로 이동
		{
			
			root.left = insertRec(root.left, key);
			root.left.parent = root;
		}
		else if (key > root.key)	// 오른쪽 서브트리로 이동
		{
			root.right = insertRec(root.right, key);
			root.right.parent = root;
		}
		return root;
	}

	void inorder() {
		inorderRec(root);
		System.out.println();
	}

	private void inorderRec(Node root) {
		if (root != null) {
			inorderRec(root.left);
			System.out.print(root.key + " ");
			inorderRec(root.right);
		}
	}
	
	public Node inorderSuccessor(Node n)
	{
		// case 1 : 오른쪽 서브트리가 존재하는 경우
		if(n.right!=null)
		{
			return minValue(n.right);
		}
		
		// case 2 : 오른쪽 서브트리가 null인 경우
		Node p = n.parent;
		// root 노드의 경우 p=null이므로 null 반환,
		// n과 p의 관계가 오른쪽 자식과 부모인 관계동안 부모를 타고 올라간다.
		while(p!=null && n==p.right) {
			n = p;
			p = p.parent;
		}
		return p;
	}
	
	// n 트리를 기준으로 제일 작은 수의 노드를 반환
	private Node minValue(Node n)
	{
		Node current = n;
		
		// 노드 n을 기준으로 제일 왼쪽 자식 노드를 탐색한다.
		while(current.left!=null)
		{
			current = current.left;
		}
		return current;
		
	}
}
```

```
import org.junit.jupiter.api.Test;

import Tree.BST.Implement.BinarySearchTree.Node;



class BinarySearchTreeTest {	
	@Test
	void deleteTest() {
		BinarySearchTree tree = new BinarySearchTree();
		
		tree.insert(50);
		tree.insert(30);
		tree.insert(20);
		tree.insert(40);
		tree.insert(70);
		tree.insert(60);
		tree.insert(80);
		
		System.out.println("Inorder traversal of the given tree");
		tree.inorder();
		
		System.out.println("Delete 20");
		tree.delete(20);
		System.out.println("Inorder traversal of the modified tree");
		tree.inorder();	// Expected Output : 30 40 50 60 70 80
		
		System.out.println("Delete 30");
		tree.delete(30);
		System.out.println("Inorder traversal of the modified tree");
		tree.inorder();	// 40 50 60 70 80
		
		System.out.println("Delete 50");
		tree.delete(50);
		System.out.println("Inorder traversal of the modified tree");
		tree.inorder(); // 40 60 70 80
	}

}
```

```
Output

Inorder traversal of the given tree
20 30 40 50 60 70 80 
Delete 20
Inorder traversal of the modified tree
30 40 50 60 70 80 
Delete 30
Inorder traversal of the modified tree
40 50 60 70 80 
Delete 50
Inorder traversal of the modified tree
40 60 70 80
```

시간 복잡도(Time Complexity) : O(h), h는 이진 탐색 트리의 높이(height)로 가정합니다. 최악의 경우 삭제될 노드를 찾기 위해 루트 노드에서 가장 깊숙한 리프 노드로 순회를 해야 합니다. 탐색과 삭제의 연산이 n번 정도 걸릴 수 있습니다. 

### References

> source code : https://github.com/yonghwankim-dev/DataStruct  
> https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/
