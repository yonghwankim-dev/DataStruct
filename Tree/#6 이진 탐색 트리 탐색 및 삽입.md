### 1\. 이진 탐색 트리의 특징

1.  특정 노드를 기준으로 왼쪽 서브트리는 특정 노드의 키값보다 작다
2.  특정 노드를 기준으로 오른쪽 서브트리는 특정 노드의 키값보다 크다
3.  왼쪽, 오른쪽 서브트리들의 노드들은 또다른 자식 서브트리로 구성된다.

![](https://github.com/yonghwankim-dev/DataStruct/tree/main/Tree/img/%236%20%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89%20%ED%8A%B8%EB%A6%AC%20%ED%83%90%EC%83%89%20%EB%B0%8F%20%EC%82%BD%EC%9E%85)

위의 이진 탐색 트리의 특징들은 탐색, 최솟값, 최대값과 같은 기능들을 빠르게 할 수 있도록 키 값들간에 순서를 제공합니다. 만약 트리에 순서가 없다면 모든 키값과 주어진 키값을 비교해야 합니다.

### 2\. 이진 탐색 트리의 탐색 수행 과정

1.  시작은 root 노드에서 시작합니다.
2.  현재 노드와 탐색하고자 하는 key값을 비교합니다.
3.  key값이 현재 노드의 값보다 작으면 왼쪽 서브트리로 이동
4.  key값이 현재 노드의 값보다 크면 오른쪽 서브트리로 이동
5.  key값이 현재 노드의 값과 동일하면 해당 노드를 반환하고 종료

![](https://github.com/yonghwankim-dev/DataStruct/blob/main/Tree/img/%236%20%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89%20%ED%8A%B8%EB%A6%AC%20%ED%83%90%EC%83%89%20%EB%B0%8F%20%EC%82%BD%EC%9E%85/02_searchBST.png)

### 3\. 이진 탐색 트리의 탐색 구현

```
// 이진탐색트리에서 주어진 키값을 탐색하기 위한 탐색 기능
public Node search(Node root, int key)
{
    // Base Cases : root 노드가 null이거나 key값과 동일한 경우
    if (root==null || root.key==key)
        return root;
 
    // kye값이 root 노드의 key값보다 큰 경우, 오른쪽 서브트리로 이동
    if (root.key < key)
       return search(root.right, key);
 
    // key값이 root 노드의 key값보다 작은 경우, 왼쪽 서브트리로 이동
    return search(root.left, key);
}
```

### 3\. 이진 탐색 트리의 삽입 수행 과정

1.  삽입시 Root 노드부터 시작합니다.
2.  Root노드와 삽입할 key값을 비교하여 key값이 Root노드보다 작으면 왼쪽 서브트리로 이동, key값이 Root노드보다 크면 오른쪽 서브트리로 이동, 재귀적인 연산이후 Root노드가 null이 될때까지 이동한다.
3.  비어있는 Root노드에 노드 삽입

![](https://github.com/yonghwankim-dev/DataStruct/blob/main/Tree/img/%236%20%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89%20%ED%8A%B8%EB%A6%AC%20%ED%83%90%EC%83%89%20%EB%B0%8F%20%EC%82%BD%EC%9E%85/03_insertBST.png)

### 4\. 이진 탐색 트리의 삽입 구현

```
// 이진 탐색 트리의 탐색, 삽입, 삭제를 예제
public class BinarySearchTree {
	static class Node 
	{
		int key;
		Node left, right;

		public Node(int item) 
		{
			key = item;
			left = right = null;
		}
	}

	Node root;

	BinarySearchTree() {
		root = null;
	}

	void insert(int key) {
		root = insertRec(root, key);
	}

	private Node insertRec(Node root, int key) {

		// 루트 노드가 비어있는 경우 생성
		if (root == null) {
			root = new Node(key);
			return root;
		}

		if (key < root.key)	// 왼쪽 서브트리로 이동
		{
			root.left = insertRec(root.left, key);
		}
		else if (key > root.key)	// 오른쪽 서브트리로 이동
		{
			root.right = insertRec(root.right, key);
		}
		return root;
	}

	void inorder() {
		inorderRec(root);
		System.out.println();
	}

	private void inorderRec(Node root) {
		if (root != null) {
			inorderRec(root.left);
			System.out.print(root.key + " ");
			inorderRec(root.right);
		}
	}
}
```

```
import org.junit.jupiter.api.Test;

class BinarySearchTreeTest {

	@Test
	void insertTest() {
		BinarySearchTree tree = new BinarySearchTree();

		tree.insert(50);
		tree.insert(30);
		tree.insert(20);
		tree.insert(40);
		tree.insert(70);
		tree.insert(60);
		tree.insert(80);

		tree.inorder();	// Expected output : 20 30 40 50 60 70 80
	}

}
```

```
Output

20 30 40 50 60 70 80
```

### References

> source code : https://github.com/yonghwankim-dev/DataStruct  
> https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/
